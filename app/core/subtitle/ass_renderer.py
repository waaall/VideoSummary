"""ASS subtitle renderer"""

import os
import re
import subprocess
import tempfile
from pathlib import Path
from typing import TYPE_CHECKING, Callable, Optional, Tuple

from PIL import Image

from app.config import CACHE_PATH, FONTS_PATH, RESOURCE_PATH
from app.core.entities import SubtitleLayoutEnum
from app.core.utils.logger import setup_logger

from .ass_utils import auto_wrap_ass_file

if TYPE_CHECKING:
    from app.core.asr.asr_data import ASRData

logger = setup_logger("subtitle.ass")
ASS_TEMPLATE = """[Script Info]
; Script generated by VideoSummary
ScriptType: v4.00+
PlayResX: {video_width}
PlayResY: {video_height}

{style_str}

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
{dialogue}
"""


def _check_cuda_available() -> bool:
    """检查 CUDA 是否可用"""
    try:
        # 检查 ffmpeg 是否支持 cuda
        result = subprocess.run(
            ["ffmpeg", "-hwaccels"],
            capture_output=True,
            text=True,
            creationflags=(
                getattr(subprocess, "CREATE_NO_WINDOW", 0) if os.name == "nt" else 0
            ),
        )
        if "cuda" not in result.stdout.lower():
            return False

        # 进一步检查 CUDA 设备信息
        result = subprocess.run(
            ["ffmpeg", "-hide_banner", "-init_hw_device", "cuda"],
            capture_output=True,
            text=True,
            creationflags=(
                getattr(subprocess, "CREATE_NO_WINDOW", 0) if os.name == "nt" else 0
            ),
        )

        # 如果 stderr 中包含错误信息，说明 CUDA 不可用
        if any(
            error in result.stderr.lower()
            for error in ["cannot load cuda", "failed to load", "error"]
        ):
            return False

        return True

    except Exception as e:
        logger.exception(f"Check CUDA available error: {str(e)}")
        return False


def _scale_ass_style(style_str: str, scale_factor: float) -> str:
    """
    缩放 ASS 样式中的数值参数

    Args:
        style_str: 原始 ASS 样式字符串（720P）
        scale_factor: 缩放因子

    Returns:
        缩放后的 ASS 样式字符串
    """
    if scale_factor == 1.0:
        return style_str

    lines = style_str.split("\n")
    scaled_lines = []

    for line in lines:
        if line.startswith("Style:"):
            parts = line.split(",")
            if len(parts) >= 23:
                # parts[2]: Fontsize
                parts[2] = str(int(float(parts[2]) * scale_factor))
                # parts[13]: Spacing
                parts[13] = str(float(parts[13]) * scale_factor)
                # parts[16]: Outline
                parts[16] = str(float(parts[16]) * scale_factor)
                # parts[21]: MarginV (垂直间距)
                parts[21] = str(int(float(parts[21]) * scale_factor))
                line = ",".join(parts)
        scaled_lines.append(line)

    return "\n".join(scaled_lines)


def render_ass_preview(
    style_str: str,
    preview_text: Tuple[str, Optional[str]],
    bg_image_path: str,
    width: Optional[int] = None,
    height: Optional[int] = None,
    reference_height: int = 720,
) -> str:
    """
    生成 ASS 样式字幕预览图

    Args:
        style_str: ASS 样式字符串（包含 PlayResY）
        preview_text: (原文, 译文) 元组，译文可以为 None
        bg_image_path: 背景图片路径
        width: 图片宽度（None=从bg_image_path自动获取）
        height: 图片高度（None=从bg_image_path自动获取）
        reference_height: 参考高度（固定720P）
    Returns:
        生成的预览图路径
    """
    # 自动获取图片尺寸
    if width is None or height is None:
        bg_path = Path(bg_image_path)
        if bg_path.exists():
            with Image.open(bg_path) as img:
                actual_width, actual_height = img.size
                width = width or actual_width
                height = height or actual_height
        else:
            width = width or 1920
            height = height or 1080

    original_text, translate_text = preview_text

    # 构建对话行
    if translate_text:
        dialogue = [
            f"Dialogue: 0,0:00:00.00,0:00:01.00,Secondary,,0,0,0,,{translate_text}",
            f"Dialogue: 0,0:00:00.00,0:00:01.00,Default,,0,0,0,,{original_text}",
        ]
    else:
        dialogue = [
            f"Dialogue: 0,0:00:00.00,0:00:01.00,Default,,0,0,0,,{original_text}"
        ]

    # 生成 ASS 内容
    ass_content = ASS_TEMPLATE.format(
        style_str=style_str,
        dialogue=os.linesep.join(dialogue),
        video_width=width,
        video_height=height,
    )

    # 从 ASS 内容中提取参考高度，根据图片高度自动缩放样式
    scale_factor = height / reference_height
    style_str = _scale_ass_style(style_str, scale_factor)

    # 重新生成缩放后的 ASS 内容
    ass_content = ASS_TEMPLATE.format(
        style_str=style_str,
        dialogue=os.linesep.join(dialogue),
        video_width=width,
        video_height=height,
    )

    # 创建临时 ASS 文件
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".ass", delete=False, encoding="utf-8"
    ) as f:
        f.write(ass_content)
        temp_ass_path = f.name

    processed_ass = temp_ass_path
    try:
        # 自动换行处理
        processed_ass = auto_wrap_ass_file(temp_ass_path)

        # 确保背景图片存在
        bg_path_obj = Path(bg_image_path)
        if not bg_path_obj.exists():
            # 使用默认黑色背景
            default_bg = RESOURCE_PATH / "assets" / "default_bg.png"
            if not default_bg.exists():
                default_bg.parent.mkdir(parents=True, exist_ok=True)
                # 生成黑色背景
                subprocess.run(
                    [
                        "ffmpeg",
                        "-f",
                        "lavfi",
                        "-i",
                        f"color=c=black:s={width}x{height}",
                        "-frames:v",
                        "1",
                        str(default_bg),
                    ],
                    capture_output=True,
                    creationflags=(
                        getattr(subprocess, "CREATE_NO_WINDOW", 0)
                        if os.name == "nt"
                        else 0
                    ),
                )
            bg_path_obj = default_bg

        # 生成预览图
        output_path = CACHE_PATH / "ass_preview.png"
        output_path.parent.mkdir(parents=True, exist_ok=True)

        # 处理 ASS 文件路径（Windows 兼容）
        ass_file_escaped = processed_ass.replace("\\", "/").replace(":", r"\\:")

        # 添加内置字体目录支持
        fonts_dir_escaped = str(FONTS_PATH).replace("\\", "/").replace(":", r"\\:")

        cmd = [
            "ffmpeg",
            "-y",
            "-i",
            str(bg_path_obj),
            "-vf",
            f"ass={ass_file_escaped}:fontsdir={fonts_dir_escaped}",
            "-frames:v",
            "1",
            str(output_path),
        ]

        result = subprocess.run(
            cmd,
            capture_output=True,
            creationflags=(
                getattr(subprocess, "CREATE_NO_WINDOW", 0) if os.name == "nt" else 0
            ),
        )

        if result.returncode != 0:
            logger.error(f"FFmpeg 预览生成失败: {result.stderr}")

        return str(output_path)

    finally:
        # 清理临时文件
        Path(temp_ass_path).unlink(missing_ok=True)
        if processed_ass != temp_ass_path:
            Path(processed_ass).unlink(missing_ok=True)


def _get_video_resolution(video_path: str) -> Tuple[int, int]:
    """获取视频分辨率"""
    result = subprocess.run(
        ["ffmpeg", "-i", video_path],
        capture_output=True,
        text=True,
        creationflags=(
            getattr(subprocess, "CREATE_NO_WINDOW", 0) if os.name == "nt" else 0
        ),
    )

    # 从 ffmpeg 输出中解析分辨率
    pattern = r"(\d{2,5})x(\d{2,5})"
    match = re.search(pattern, result.stderr)
    if match:
        return int(match.group(1)), int(match.group(2))
    return 1920, 1080  # 默认返回 1080P


def render_ass_video(
    video_path: str,
    asr_data: "ASRData",
    output_path: str,
    style_str: str,
    layout: SubtitleLayoutEnum,
    crf: int = 23,
    preset: str = "medium",
    progress_callback: Optional[Callable] = None,
    reference_height: int = 720,
) -> None:
    """
    渲染 ASS 样式字幕到视频（硬字幕）

    Args:
        video_path: 输入视频路径
        asr_data: 字幕数据
        output_path: 输出视频路径
        style_str: ASS 样式字符串（包含 PlayResY）
        layout: 字幕布局
        crf: 视频质量参数 (0-51，越小越好)
        preset: FFmpeg 编码预设
        progress_callback: 进度回调 (progress: str, message: str) -> None
        reference_height: 参考高度（固定720P）
    """
    # 检查字幕数据是否为空
    if not asr_data or not asr_data.segments:
        raise ValueError("字幕数据为空，无法渲染视频")

    # 获取视频分辨率
    width, height = _get_video_resolution(video_path)

    # 根据视频高度自动缩放样式
    scale_factor = height / reference_height
    style_str = _scale_ass_style(style_str, scale_factor)

    # 生成临时 ASS 文件（传入实际视频分辨率）
    with tempfile.NamedTemporaryFile(
        mode="w", suffix=".ass", delete=False, encoding="utf-8"
    ) as temp_file:
        ass_content = asr_data.to_ass(
            style_str=style_str,
            layout=layout,
            save_path=None,
            video_width=width,
            video_height=height,
        )
        temp_file.write(ass_content)
        temp_ass_path = temp_file.name

    processed_subtitle = temp_ass_path
    try:
        # 自动换行处理
        processed_subtitle = auto_wrap_ass_file(temp_ass_path)

        # 转义字幕路径
        subtitle_path_escaped = Path(processed_subtitle).as_posix().replace(":", r"\:")

        # 构建 FFmpeg 命令
        vcodec = "libx264"
        if Path(output_path).suffix.lower() == ".webm":
            vcodec = "libvpx-vp9"
            logger.info("WebM 格式视频，使用 libvpx-vp9 编码器")

        # 添加内置字体目录支持
        fonts_dir_escaped = FONTS_PATH.as_posix().replace(":", r"\:")

        # 统一使用 ass 滤镜
        vf = f"ass='{subtitle_path_escaped}':fontsdir='{fonts_dir_escaped}'"

        # 检查 CUDA 是否可用
        use_cuda = _check_cuda_available()
        cmd = ["ffmpeg"]
        if use_cuda:
            logger.info("使用 CUDA 加速")
            cmd.extend(["-hwaccel", "cuda"])

        cmd.extend(
            [
                "-i",
                video_path,
                "-acodec",
                "copy",
                "-vcodec",
                vcodec,
                "-crf",
                str(crf),
                "-preset",
                preset,
                "-vf",
                vf,
                "-y",
                output_path,
            ]
        )

        cmd_str = subprocess.list2cmdline(cmd)
        logger.info(f"添加字幕执行命令: {cmd_str}")

        # 执行 FFmpeg
        process = None
        try:
            process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding="utf-8",
                errors="replace",
                creationflags=(
                    getattr(subprocess, "CREATE_NO_WINDOW", 0) if os.name == "nt" else 0
                ),
            )

            # 实时读取输出并调用回调
            total_duration = None
            current_time = 0

            while True:
                output_line = process.stderr.readline()
                if not output_line or (process.poll() is not None):
                    break
                if not progress_callback:
                    continue

                # 解析总时长
                if total_duration is None:
                    duration_match = re.search(
                        r"Duration: (\d{2}):(\d{2}):(\d{2}\.\d{2})", output_line
                    )
                    if duration_match:
                        h, m, s = map(float, duration_match.groups())
                        total_duration = h * 3600 + m * 60 + s

                # 解析当前处理时间
                time_match = re.search(
                    r"time=(\d{2}):(\d{2}):(\d{2}\.\d{2})", output_line
                )
                if time_match:
                    h, m, s = map(float, time_match.groups())
                    current_time = h * 3600 + m * 60 + s

                # 计算进度百分比
                if total_duration:
                    progress = (current_time / total_duration) * 100
                    progress_callback(f"{round(progress)}", "正在合成")

            if progress_callback:
                progress_callback("100", "合成完成")

            # 检查返回码
            return_code = process.wait()
            if return_code != 0:
                error_info = process.stderr.read()
                logger.error("== ffmpeg 渲染 ASS 字幕失败 ==")
                logger.error(f"返回码: {return_code}")
                logger.error(f"命令: {cmd_str}")
                if error_info:
                    logger.error(f"错误信息: {error_info}")
                raise Exception(f"FFmpeg 返回码: {return_code}")

            logger.info("ASS 字幕渲染完成")

        except subprocess.SubprocessError as e:
            logger.error("== ffmpeg 进程执行异常 ==")
            logger.error(f"错误: {str(e)}")
            if process and process.poll() is None:
                process.kill()
            raise
        except Exception as e:
            logger.error(f"ASS 字幕渲染出错: {str(e)}")
            if process and process.poll() is None:
                process.kill()
            raise

    finally:
        # 清理临时文件
        Path(temp_ass_path).unlink(missing_ok=True)
        if processed_subtitle != temp_ass_path:
            Path(processed_subtitle).unlink(missing_ok=True)
